{"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "GNU C17", "fullName": "GNU C17 (GCC) version 13.2.0 (x86_64-linux-gnu)", "version": "13.2.0", "informationUri": "https://gcc.gnu.org/gcc-13/", "rules": [{"id": "-Wint-conversion", "helpUri": "https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wint-conversion"}]}}, "invocations": [{"executionSuccessful": true, "toolExecutionNotifications": []}], "originalUriBaseIds": {"PWD": {"uri": "file:///repo/"}}, "artifacts": [{"location": {"uri": "/usr/include/stdlib.h"}, "contents": {"text": "/* Copyright (C) 1991-2022 Free Software Foundation, Inc.\n   Copyright The GNU Toolchain Authors.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n/*\n *\tISO C99 Standard: 7.20 General utilities\t<stdlib.h>\n */\n\n#ifndef\t_STDLIB_H\n\n#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION\n#include <bits/libc-header-start.h>\n\n/* Get size_t, wchar_t and NULL from <stddef.h>.  */\n#define __need_size_t\n#define __need_wchar_t\n#define __need_NULL\n#include <stddef.h>\n\n__BEGIN_DECLS\n\n#define\t_STDLIB_H\t1\n\n#if (defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H\n/* XPG requires a few symbols from <sys/wait.h> being defined.  */\n# include <bits/waitflags.h>\n# include <bits/waitstatus.h>\n\n/* Define the macros <sys/wait.h> also would define this way.  */\n# define WEXITSTATUS(status)\t__WEXITSTATUS (status)\n# define WTERMSIG(status)\t__WTERMSIG (status)\n# define WSTOPSIG(status)\t__WSTOPSIG (status)\n# define WIFEXITED(status)\t__WIFEXITED (status)\n# define WIFSIGNALED(status)\t__WIFSIGNALED (status)\n# define WIFSTOPPED(status)\t__WIFSTOPPED (status)\n# ifdef __WIFCONTINUED\n#  define WIFCONTINUED(status)\t__WIFCONTINUED (status)\n# endif\n#endif\t/* X/Open or XPG7 and <sys/wait.h> not included.  */\n\n/* _FloatN API tests for enablement.  */\n#include <bits/floatn.h>\n\n/* Returned by `div'.  */\ntypedef struct\n  {\n    int quot;\t\t\t/* Quotient.  */\n    int rem;\t\t\t/* Remainder.  */\n  } div_t;\n\n/* Returned by `ldiv'.  */\n#ifndef __ldiv_t_defined\ntypedef struct\n  {\n    long int quot;\t\t/* Quotient.  */\n    long int rem;\t\t/* Remainder.  */\n  } ldiv_t;\n# define __ldiv_t_defined\t1\n#endif\n\n#if defined __USE_ISOC99 && !defined __lldiv_t_defined\n/* Returned by `lldiv'.  */\n__extension__ typedef struct\n  {\n    long long int quot;\t\t/* Quotient.  */\n    long long int rem;\t\t/* Remainder.  */\n  } lldiv_t;\n# define __lldiv_t_defined\t1\n#endif\n\n\n/* The largest number rand will return (same as INT_MAX).  */\n#define\tRAND_MAX\t2147483647\n\n\n/* We define these the same for all machines.\n   Changes from this to the outside world should be done in `_exit'.  */\n#define\tEXIT_FAILURE\t1\t/* Failing exit status.  */\n#define\tEXIT_SUCCESS\t0\t/* Successful exit status.  */\n\n\n/* Maximum length of a multibyte character in the current locale.  */\n#define\tMB_CUR_MAX\t(__ctype_get_mb_cur_max ())\nextern size_t __ctype_get_mb_cur_max (void) __THROW __wur;\n\n\n/* Convert a string to a floating-point number.  */\nextern double atof (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n/* Convert a string to an integer.  */\nextern int atoi (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n/* Convert a string to a long integer.  */\nextern long int atol (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n\n#ifdef __USE_ISOC99\n/* Convert a string to a long long integer.  */\n__extension__ extern long long int atoll (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n#endif\n\n/* Convert a string to a floating-point number.  */\nextern double strtod (const char *__restrict __nptr,\n\t\t      char **__restrict __endptr)\n     __THROW __nonnull ((1));\n\n#ifdef\t__USE_ISOC99\n/* Likewise for `float' and `long double' sizes of floating-point numbers.  */\nextern float strtof (const char *__restrict __nptr,\n\t\t     char **__restrict __endptr) __THROW __nonnull ((1));\n\nextern long double strtold (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n/* Likewise for '_FloatN' and '_FloatNx'.  */\n\n#if __HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float16 strtof16 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float32 strtof32 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float64 strtof64 (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float128 strtof128 (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float32x strtof32x (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float64x strtof64x (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n#if __HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern _Float128x strtof128x (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr)\n     __THROW __nonnull ((1));\n#endif\n\n/* Convert a string to a long integer.  */\nextern long int strtol (const char *__restrict __nptr,\n\t\t\tchar **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned long integer.  */\nextern unsigned long int strtoul (const char *__restrict __nptr,\n\t\t\t\t  char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_MISC\n/* Convert a string to a quadword integer.  */\n__extension__\nextern long long int strtoq (const char *__restrict __nptr,\n\t\t\t     char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned quadword integer.  */\n__extension__\nextern unsigned long long int strtouq (const char *__restrict __nptr,\n\t\t\t\t       char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n#endif /* Use misc.  */\n\n#ifdef __USE_ISOC99\n/* Convert a string to a quadword integer.  */\n__extension__\nextern long long int strtoll (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n/* Convert a string to an unsigned quadword integer.  */\n__extension__\nextern unsigned long long int strtoull (const char *__restrict __nptr,\n\t\t\t\t\tchar **__restrict __endptr, int __base)\n     __THROW __nonnull ((1));\n#endif /* ISO C99 or use MISC.  */\n\n/* Convert a floating-point number to a string.  */\n#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)\nextern int strfromd (char *__dest, size_t __size, const char *__format,\n\t\t     double __f)\n     __THROW __nonnull ((3));\n\nextern int strfromf (char *__dest, size_t __size, const char *__format,\n\t\t     float __f)\n     __THROW __nonnull ((3));\n\nextern int strfroml (char *__dest, size_t __size, const char *__format,\n\t\t     long double __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf16 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float16 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf32 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float32 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf64 (char *__dest, size_t __size, const char * __format,\n\t\t       _Float64 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf128 (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float128 __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf32x (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float32x __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf64x (char *__dest, size_t __size, const char * __format,\n\t\t\t_Float64x __f)\n     __THROW __nonnull ((3));\n#endif\n\n#if __HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)\nextern int strfromf128x (char *__dest, size_t __size, const char * __format,\n\t\t\t _Float128x __f)\n     __THROW __nonnull ((3));\n#endif\n\n\n#ifdef __USE_GNU\n/* Parallel versions of the functions above which take the locale to\n   use as an additional parameter.  These are GNU extensions inspired\n   by the POSIX.1-2008 extended locale API.  */\n# include <bits/types/locale_t.h>\n\nextern long int strtol_l (const char *__restrict __nptr,\n\t\t\t  char **__restrict __endptr, int __base,\n\t\t\t  locale_t __loc) __THROW __nonnull ((1, 4));\n\nextern unsigned long int strtoul_l (const char *__restrict __nptr,\n\t\t\t\t    char **__restrict __endptr,\n\t\t\t\t    int __base, locale_t __loc)\n     __THROW __nonnull ((1, 4));\n\n__extension__\nextern long long int strtoll_l (const char *__restrict __nptr,\n\t\t\t\tchar **__restrict __endptr, int __base,\n\t\t\t\tlocale_t __loc)\n     __THROW __nonnull ((1, 4));\n\n__extension__\nextern unsigned long long int strtoull_l (const char *__restrict __nptr,\n\t\t\t\t\t  char **__restrict __endptr,\n\t\t\t\t\t  int __base, locale_t __loc)\n     __THROW __nonnull ((1, 4));\n\nextern double strtod_l (const char *__restrict __nptr,\n\t\t\tchar **__restrict __endptr, locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\nextern float strtof_l (const char *__restrict __nptr,\n\t\t       char **__restrict __endptr, locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\nextern long double strtold_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n\n# if __HAVE_FLOAT16\nextern _Float16 strtof16_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT32\nextern _Float32 strtof32_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT64\nextern _Float64 strtof64_l (const char *__restrict __nptr,\n\t\t\t    char **__restrict __endptr,\n\t\t\t    locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT128\nextern _Float128 strtof128_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT32X\nextern _Float32x strtof32x_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT64X\nextern _Float64x strtof64x_l (const char *__restrict __nptr,\n\t\t\t      char **__restrict __endptr,\n\t\t\t      locale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n\n# if __HAVE_FLOAT128X\nextern _Float128x strtof128x_l (const char *__restrict __nptr,\n\t\t\t\tchar **__restrict __endptr,\n\t\t\t\tlocale_t __loc)\n     __THROW __nonnull ((1, 3));\n# endif\n#endif /* GNU */\n\n\n#ifdef __USE_EXTERN_INLINES\n__extern_inline int\n__NTH (atoi (const char *__nptr))\n{\n  return (int) strtol (__nptr, (char **) NULL, 10);\n}\n__extern_inline long int\n__NTH (atol (const char *__nptr))\n{\n  return strtol (__nptr, (char **) NULL, 10);\n}\n\n# ifdef __USE_ISOC99\n__extension__ __extern_inline long long int\n__NTH (atoll (const char *__nptr))\n{\n  return strtoll (__nptr, (char **) NULL, 10);\n}\n# endif\n#endif /* Optimizing and Inlining.  */\n\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Convert N to base 64 using the digits \"./0-9A-Za-z\", least-significant\n   digit first.  Returns a pointer to static storage overwritten by the\n   next call.  */\nextern char *l64a (long int __n) __THROW __wur;\n\n/* Read a number from a string S in base 64 as above.  */\nextern long int a64l (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1)) __wur;\n\n#endif\t/* Use misc || extended X/Open.  */\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n# include <sys/types.h>\t/* we need int32_t... */\n\n/* These are the functions that actually do things.  The `random', `srandom',\n   `initstate' and `setstate' functions are those from BSD Unices.\n   The `rand' and `srand' functions are required by the ANSI standard.\n   We provide both interfaces to the same random number generator.  */\n/* Return a random long integer between 0 and 2^31-1 inclusive.  */\nextern long int random (void) __THROW;\n\n/* Seed the random number generator with the given number.  */\nextern void srandom (unsigned int __seed) __THROW;\n\n/* Initialize the random number generator to use state buffer STATEBUF,\n   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,\n   32, 64, 128 and 256, the bigger the better; values less than 8 will\n   cause an error and values greater than 256 will be rounded down.  */\nextern char *initstate (unsigned int __seed, char *__statebuf,\n\t\t\tsize_t __statelen) __THROW __nonnull ((2));\n\n/* Switch the random number generator to state buffer STATEBUF,\n   which should have been previously initialized by `initstate'.  */\nextern char *setstate (char *__statebuf) __THROW __nonnull ((1));\n\n\n# ifdef __USE_MISC\n/* Reentrant versions of the `random' family of functions.\n   These functions all use the following data structure to contain\n   state, rather than global state variables.  */\n\nstruct random_data\n  {\n    int32_t *fptr;\t\t/* Front pointer.  */\n    int32_t *rptr;\t\t/* Rear pointer.  */\n    int32_t *state;\t\t/* Array of state values.  */\n    int rand_type;\t\t/* Type of random number generator.  */\n    int rand_deg;\t\t/* Degree of random number generator.  */\n    int rand_sep;\t\t/* Distance between front and rear.  */\n    int32_t *end_ptr;\t\t/* Pointer behind state table.  */\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n\t\t     int32_t *__restrict __result) __THROW __nonnull ((1, 2));\n\nextern int srandom_r (unsigned int __seed, struct random_data *__buf)\n     __THROW __nonnull ((2));\n\nextern int initstate_r (unsigned int __seed, char *__restrict __statebuf,\n\t\t\tsize_t __statelen,\n\t\t\tstruct random_data *__restrict __buf)\n     __THROW __nonnull ((2, 4));\n\nextern int setstate_r (char *__restrict __statebuf,\n\t\t       struct random_data *__restrict __buf)\n     __THROW __nonnull ((1, 2));\n# endif\t/* Use misc.  */\n#endif\t/* Use extended X/Open || misc. */\n\n\n/* Return a random integer between 0 and RAND_MAX inclusive.  */\nextern int rand (void) __THROW;\n/* Seed the random number generator with the given number.  */\nextern void srand (unsigned int __seed) __THROW;\n\n#ifdef __USE_POSIX199506\n/* Reentrant interface according to POSIX.1.  */\nextern int rand_r (unsigned int *__seed) __THROW;\n#endif\n\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* System V style 48-bit random number generator functions.  */\n\n/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */\nextern double drand48 (void) __THROW;\nextern double erand48 (unsigned short int __xsubi[3]) __THROW __nonnull ((1));\n\n/* Return non-negative, long integer in [0,2^31).  */\nextern long int lrand48 (void) __THROW;\nextern long int nrand48 (unsigned short int __xsubi[3])\n     __THROW __nonnull ((1));\n\n/* Return signed, long integers in [-2^31,2^31).  */\nextern long int mrand48 (void) __THROW;\nextern long int jrand48 (unsigned short int __xsubi[3])\n     __THROW __nonnull ((1));\n\n/* Seed random number generator.  */\nextern void srand48 (long int __seedval) __THROW;\nextern unsigned short int *seed48 (unsigned short int __seed16v[3])\n     __THROW __nonnull ((1));\nextern void lcong48 (unsigned short int __param[7]) __THROW __nonnull ((1));\n\n# ifdef __USE_MISC\n/* Data structure for communication with thread safe versions.  This\n   type is to be regarded as opaque.  It's only exported because users\n   have to allocate objects of this type.  */\nstruct drand48_data\n  {\n    unsigned short int __x[3];\t/* Current state.  */\n    unsigned short int __old_x[3]; /* Old state.  */\n    unsigned short int __c;\t/* Additive const. in congruential formula.  */\n    unsigned short int __init;\t/* Flag for initializing.  */\n    __extension__ unsigned long long int __a;\t/* Factor in congruential\n\t\t\t\t\t\t   formula.  */\n  };\n\n/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */\nextern int drand48_r (struct drand48_data *__restrict __buffer,\n\t\t      double *__restrict __result) __THROW __nonnull ((1, 2));\nextern int erand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      double *__restrict __result) __THROW __nonnull ((1, 2));\n\n/* Return non-negative, long integer in [0,2^31).  */\nextern int lrand48_r (struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\nextern int nrand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\n\n/* Return signed, long integers in [-2^31,2^31).  */\nextern int mrand48_r (struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\nextern int jrand48_r (unsigned short int __xsubi[3],\n\t\t      struct drand48_data *__restrict __buffer,\n\t\t      long int *__restrict __result)\n     __THROW __nonnull ((1, 2));\n\n/* Seed random number generator.  */\nextern int srand48_r (long int __seedval, struct drand48_data *__buffer)\n     __THROW __nonnull ((2));\n\nextern int seed48_r (unsigned short int __seed16v[3],\n\t\t     struct drand48_data *__buffer) __THROW __nonnull ((1, 2));\n\nextern int lcong48_r (unsigned short int __param[7],\n\t\t      struct drand48_data *__buffer)\n     __THROW __nonnull ((1, 2));\n\n/* Return a random integer between zero and 2**32-1 (inclusive).  */\nextern __uint32_t arc4random (void)\n     __THROW __wur;\n\n/* Fill the buffer with random data.  */\nextern void arc4random_buf (void *__buf, size_t __size)\n     __THROW __nonnull ((1));\n\n/* Return a random number between zero (inclusive) and the specified\n   limit (exclusive).  */\nextern __uint32_t arc4random_uniform (__uint32_t __upper_bound)\n     __THROW __wur;\n# endif\t/* Use misc.  */\n#endif\t/* Use misc or X/Open.  */\n\n/* Allocate SIZE bytes of memory.  */\nextern void *malloc (size_t __size) __THROW __attribute_malloc__\n     __attribute_alloc_size__ ((1)) __wur;\n/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */\nextern void *calloc (size_t __nmemb, size_t __size)\n     __THROW __attribute_malloc__ __attribute_alloc_size__ ((1, 2)) __wur;\n\n/* Re-allocate the previously allocated block\n   in PTR, making the new block SIZE bytes long.  */\n/* __attribute_malloc__ is not used, because if realloc returns\n   the same pointer that was passed to it, aliasing needs to be allowed\n   between objects pointed by the old and new pointers.  */\nextern void *realloc (void *__ptr, size_t __size)\n     __THROW __attribute_warn_unused_result__ __attribute_alloc_size__ ((2));\n\n/* Free a block allocated by `malloc', `realloc' or `calloc'.  */\nextern void free (void *__ptr) __THROW;\n\n#ifdef __USE_MISC\n/* Re-allocate the previously allocated block in PTR, making the new\n   block large enough for NMEMB elements of SIZE bytes each.  */\n/* __attribute_malloc__ is not used, because if reallocarray returns\n   the same pointer that was passed to it, aliasing needs to be allowed\n   between objects pointed by the old and new pointers.  */\nextern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)\n     __THROW __attribute_warn_unused_result__\n     __attribute_alloc_size__ ((2, 3))\n    __attr_dealloc_free;\n\n/* Add reallocarray as its own deallocator.  */\nextern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)\n     __THROW __attr_dealloc (reallocarray, 1);\n#endif\n\n#ifdef __USE_MISC\n# include <alloca.h>\n#endif /* Use misc.  */\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \\\n    || defined __USE_MISC\n/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */\nextern void *valloc (size_t __size) __THROW __attribute_malloc__\n     __attribute_alloc_size__ ((1)) __wur;\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */\nextern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)\n     __THROW __nonnull ((1)) __wur;\n#endif\n\n#ifdef __USE_ISOC11\n/* ISO C variant of aligned allocation.  */\nextern void *aligned_alloc (size_t __alignment, size_t __size)\n     __THROW __attribute_malloc__ __attribute_alloc_align__ ((1))\n     __attribute_alloc_size__ ((2)) __wur;\n#endif\n\n/* Abort execution and generate a core-dump.  */\nextern void abort (void) __THROW __attribute__ ((__noreturn__));\n\n\n/* Register a function to be called when `exit' is called.  */\nextern int atexit (void (*__func) (void)) __THROW __nonnull ((1));\n\n#if defined __USE_ISOC11 || defined __USE_ISOCXX11\n/* Register a function to be called when `quick_exit' is called.  */\n# ifdef __cplusplus\nextern \"C++\" int at_quick_exit (void (*__func) (void))\n     __THROW __asm (\"at_quick_exit\") __nonnull ((1));\n# else\nextern int at_quick_exit (void (*__func) (void)) __THROW __nonnull ((1));\n# endif\n#endif\n\n#ifdef\t__USE_MISC\n/* Register a function to be called with the status\n   given to `exit' and the given argument.  */\nextern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)\n     __THROW __nonnull ((1));\n#endif\n\n/* Call all functions registered with `atexit' and `on_exit',\n   in the reverse of the order in which they were registered,\n   perform stdio cleanup, and terminate program execution with STATUS.  */\nextern void exit (int __status) __THROW __attribute__ ((__noreturn__));\n\n#if defined __USE_ISOC11 || defined __USE_ISOCXX11\n/* Call all functions registered with `at_quick_exit' in the reverse\n   of the order in which they were registered and terminate program\n   execution with STATUS.  */\nextern void quick_exit (int __status) __THROW __attribute__ ((__noreturn__));\n#endif\n\n#ifdef __USE_ISOC99\n/* Terminate the program with STATUS without calling any of the\n   functions registered with `atexit' or `on_exit'.  */\nextern void _Exit (int __status) __THROW __attribute__ ((__noreturn__));\n#endif\n\n\n/* Return the value of envariable NAME, or NULL if it doesn't exist.  */\nextern char *getenv (const char *__name) __THROW __nonnull ((1)) __wur;\n\n#ifdef __USE_GNU\n/* This function is similar to the above but returns NULL if the\n   programs is running with SUID or SGID enabled.  */\nextern char *secure_getenv (const char *__name)\n     __THROW __nonnull ((1)) __wur;\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN\n/* The SVID says this is in <stdio.h>, but this seems a better place.\t*/\n/* Put STRING, which is of the form \"NAME=VALUE\", in the environment.\n   If there is no `=', remove NAME from the environment.  */\nextern int putenv (char *__string) __THROW __nonnull ((1));\n#endif\n\n#ifdef __USE_XOPEN2K\n/* Set NAME to VALUE in the environment.\n   If REPLACE is nonzero, overwrite an existing value.  */\nextern int setenv (const char *__name, const char *__value, int __replace)\n     __THROW __nonnull ((2));\n\n/* Remove the variable NAME from the environment.  */\nextern int unsetenv (const char *__name) __THROW __nonnull ((1));\n#endif\n\n#ifdef\t__USE_MISC\n/* The `clearenv' was planned to be added to POSIX.1 but probably\n   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings\n   for Fortran 77) requires this function.  */\nextern int clearenv (void) __THROW;\n#endif\n\n\n#if defined __USE_MISC \\\n    || (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)\n/* Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the file name unique.\n   Always returns TEMPLATE, it's either a temporary file name or a null\n   string if it cannot get a unique file name.  */\nextern char *mktemp (char *__template) __THROW __nonnull ((1));\n#endif\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   Returns a file descriptor open on the file for reading and writing,\n   or -1 if it cannot create a uniquely-named file.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkstemp (char *__template) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkstemp, (char *__template), mkstemp64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkstemp mkstemp64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkstemp64 (char *__template) __nonnull ((1)) __wur;\n# endif\n#endif\n\n#ifdef __USE_MISC\n/* Similar to mkstemp, but the template can have a suffix after the\n   XXXXXX.  The length of the suffix is specified in the second\n   parameter.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkstemps (char *__template, int __suffixlen) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkstemps, (char *__template, int __suffixlen),\n\t\t       mkstemps64) __nonnull ((1)) __wur;\n#  else\n#   define mkstemps mkstemps64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkstemps64 (char *__template, int __suffixlen)\n     __nonnull ((1)) __wur;\n# endif\n#endif\n\n#ifdef __USE_XOPEN2K8\n/* Create a unique temporary directory from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the directory name unique.\n   Returns TEMPLATE, or a null pointer if it cannot get a unique name.\n   The directory is created mode 700.  */\nextern char *mkdtemp (char *__template) __THROW __nonnull ((1)) __wur;\n#endif\n\n#ifdef __USE_GNU\n/* Generate a unique temporary file name from TEMPLATE similar to\n   mkstemp.  But allow the caller to pass additional flags which are\n   used in the open call to create the file..\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkostemp (char *__template, int __flags) __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkostemp, (char *__template, int __flags), mkostemp64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkostemp mkostemp64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkostemp64 (char *__template, int __flags) __nonnull ((1)) __wur;\n# endif\n\n/* Similar to mkostemp, but the template can have a suffix after the\n   XXXXXX.  The length of the suffix is specified in the second\n   parameter.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int mkostemps (char *__template, int __suffixlen, int __flags)\n     __nonnull ((1)) __wur;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (mkostemps, (char *__template, int __suffixlen,\n\t\t\t\t   int __flags), mkostemps64)\n     __nonnull ((1)) __wur;\n#  else\n#   define mkostemps mkostemps64\n#  endif\n# endif\n# ifdef __USE_LARGEFILE64\nextern int mkostemps64 (char *__template, int __suffixlen, int __flags)\n     __nonnull ((1)) __wur;\n# endif\n#endif\n\n\n/* Execute the given line as a shell command.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int system (const char *__command) __wur;\n\n\n#ifdef\t__USE_GNU\n/* Return a malloc'd string containing the canonical absolute name of the\n   existing named file.  */\nextern char *canonicalize_file_name (const char *__name)\n     __THROW __nonnull ((1)) __attribute_malloc__\n     __attr_dealloc_free __wur;\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED\n/* Return the canonical absolute name of file NAME.  If RESOLVED is\n   null, the result is malloc'd; otherwise, if the canonical name is\n   PATH_MAX chars or more, returns null with `errno' set to\n   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,\n   returns the name in RESOLVED.  */\nextern char *realpath (const char *__restrict __name,\n\t\t       char *__restrict __resolved) __THROW __wur;\n#endif\n\n\n/* Shorthand for type of comparison functions.  */\n#ifndef __COMPAR_FN_T\n# define __COMPAR_FN_T\ntypedef int (*__compar_fn_t) (const void *, const void *);\n\n# ifdef\t__USE_GNU\ntypedef __compar_fn_t comparison_fn_t;\n# endif\n#endif\n#ifdef __USE_GNU\ntypedef int (*__compar_d_fn_t) (const void *, const void *, void *);\n#endif\n\n/* Do a binary search for KEY in BASE, which consists of NMEMB elements\n   of SIZE bytes each, using COMPAR to perform the comparisons.  */\nextern void *bsearch (const void *__key, const void *__base,\n\t\t      size_t __nmemb, size_t __size, __compar_fn_t __compar)\n     __nonnull ((1, 2, 5)) __wur;\n\n#ifdef __USE_EXTERN_INLINES\n# include <bits/stdlib-bsearch.h>\n#endif\n\n/* Sort NMEMB elements of BASE, of SIZE bytes each,\n   using COMPAR to perform the comparisons.  */\nextern void qsort (void *__base, size_t __nmemb, size_t __size,\n\t\t   __compar_fn_t __compar) __nonnull ((1, 4));\n#ifdef __USE_GNU\nextern void qsort_r (void *__base, size_t __nmemb, size_t __size,\n\t\t     __compar_d_fn_t __compar, void *__arg)\n  __nonnull ((1, 4));\n#endif\n\n\n/* Return the absolute value of X.  */\nextern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;\nextern long int labs (long int __x) __THROW __attribute__ ((__const__)) __wur;\n\n#ifdef __USE_ISOC99\n__extension__ extern long long int llabs (long long int __x)\n     __THROW __attribute__ ((__const__)) __wur;\n#endif\n\n\n/* Return the `div_t', `ldiv_t' or `lldiv_t' representation\n   of the value of NUMER over DENOM. */\n/* GCC may have built-ins for these someday.  */\nextern div_t div (int __numer, int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\nextern ldiv_t ldiv (long int __numer, long int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\n\n#ifdef __USE_ISOC99\n__extension__ extern lldiv_t lldiv (long long int __numer,\n\t\t\t\t    long long int __denom)\n     __THROW __attribute__ ((__const__)) __wur;\n#endif\n\n\n#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\\n    || defined __USE_MISC\n/* Convert floating point numbers to strings.  The returned values are\n   valid only until another call to the same function.  */\n\n/* Convert VALUE to a string with NDIGIT digits and return a pointer to\n   this.  Set *DECPT with the position of the decimal character and *SIGN\n   with the sign of the number.  */\nextern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;\n\n/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT\n   with the position of the decimal character and *SIGN with the sign of\n   the number.  */\nextern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;\n\n/* If possible convert VALUE to a string with NDIGIT significant digits.\n   Otherwise use exponential representation.  The resulting string will\n   be written to BUF.  */\nextern char *gcvt (double __value, int __ndigit, char *__buf)\n     __THROW __nonnull ((3)) __wur;\n#endif\n\n#ifdef __USE_MISC\n/* Long double versions of above functions.  */\nextern char *qecvt (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign)\n     __THROW __nonnull ((3, 4)) __wur;\nextern char *qfcvt (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign)\n     __THROW __nonnull ((3, 4)) __wur;\nextern char *qgcvt (long double __value, int __ndigit, char *__buf)\n     __THROW __nonnull ((3)) __wur;\n\n\n/* Reentrant version of the functions above which provide their own\n   buffers.  */\nextern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign, char *__restrict __buf,\n\t\t   size_t __len) __THROW __nonnull ((3, 4, 5));\nextern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,\n\t\t   int *__restrict __sign, char *__restrict __buf,\n\t\t   size_t __len) __THROW __nonnull ((3, 4, 5));\n\nextern int qecvt_r (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign,\n\t\t    char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((3, 4, 5));\nextern int qfcvt_r (long double __value, int __ndigit,\n\t\t    int *__restrict __decpt, int *__restrict __sign,\n\t\t    char *__restrict __buf, size_t __len)\n     __THROW __nonnull ((3, 4, 5));\n#endif\t/* misc */\n\n\n/* Return the length of the multibyte character\n   in S, which is no longer than N.  */\nextern int mblen (const char *__s, size_t __n) __THROW;\n/* Return the length of the given multibyte character,\n   putting its `wchar_t' representation in *PWC.  */\nextern int mbtowc (wchar_t *__restrict __pwc,\n\t\t   const char *__restrict __s, size_t __n) __THROW;\n/* Put the multibyte character represented\n   by WCHAR in S, returning its length.  */\nextern int wctomb (char *__s, wchar_t __wchar) __THROW;\n\n\n/* Convert a multibyte string to a wide char string.  */\nextern size_t mbstowcs (wchar_t *__restrict  __pwcs,\n\t\t\tconst char *__restrict __s, size_t __n) __THROW\n    __attr_access ((__read_only__, 2));\n/* Convert a wide char string to multibyte string.  */\nextern size_t wcstombs (char *__restrict __s,\n\t\t\tconst wchar_t *__restrict __pwcs, size_t __n)\n     __THROW\n  __fortified_attr_access (__write_only__, 1, 3)\n  __attr_access ((__read_only__, 2));\n\n#ifdef __USE_MISC\n/* Determine whether the string value of RESPONSE matches the affirmation\n   or negative response expression as specified by the LC_MESSAGES category\n   in the program's current locale.  Returns 1 if affirmative, 0 if\n   negative, and -1 if not matching.  */\nextern int rpmatch (const char *__response) __THROW __nonnull ((1)) __wur;\n#endif\n\n\n#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\n/* Parse comma separated suboption from *OPTIONP and match against\n   strings in TOKENS.  If found return index and set *VALUEP to\n   optional value introduced by an equal sign.  If the suboption is\n   not part of TOKENS return in *VALUEP beginning of unknown\n   suboption.  On exit *OPTIONP is set to the beginning of the next\n   token or at the terminating NUL character.  */\nextern int getsubopt (char **__restrict __optionp,\n\t\t      char *const *__restrict __tokens,\n\t\t      char **__restrict __valuep)\n     __THROW __nonnull ((1, 2, 3)) __wur;\n#endif\n\n\n/* X/Open pseudo terminal handling.  */\n\n#ifdef __USE_XOPEN2KXSI\n/* Return a master pseudo-terminal handle.  */\nextern int posix_openpt (int __oflag) __wur;\n#endif\n\n#ifdef __USE_XOPEN_EXTENDED\n/* The next four functions all take a master pseudo-tty fd and\n   perform an operation on the associated slave:  */\n\n/* Chown the slave to the calling user.  */\nextern int grantpt (int __fd) __THROW;\n\n/* Release an internal lock so the slave can be opened.\n   Call after grantpt().  */\nextern int unlockpt (int __fd) __THROW;\n\n/* Return the pathname of the pseudo terminal slave associated with\n   the master FD is open on, or NULL on errors.\n   The returned storage is good until the next call to this function.  */\nextern char *ptsname (int __fd) __THROW __wur;\n#endif\n\n#ifdef __USE_GNU\n/* Store at most BUFLEN characters of the pathname of the slave pseudo\n   terminal associated with the master FD is open on in BUF.\n   Return 0 on success, otherwise an error number.  */\nextern int ptsname_r (int __fd, char *__buf, size_t __buflen)\n     __THROW __nonnull ((2)) __fortified_attr_access (__write_only__, 2, 3);\n\n/* Open a master pseudo terminal and return its file descriptor.  */\nextern int getpt (void);\n#endif\n\n#ifdef __USE_MISC\n/* Put the 1 minute, 5 minute and 15 minute load averages into the first\n   NELEM elements of LOADAVG.  Return the number written (never more than\n   three, but may be less than NELEM), or -1 if an error occurred.  */\nextern int getloadavg (double __loadavg[], int __nelem)\n     __THROW __nonnull ((1));\n#endif\n\n#if defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K\n/* Return the index into the active-logins file (utmp) for\n   the controlling terminal.  */\nextern int ttyslot (void) __THROW;\n#endif\n\n#include <bits/stdlib-float.h>\n\n/* Define some macros helping to catch buffer overflows.  */\n#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function\n# include <bits/stdlib.h>\n#endif\n\n#include <bits/floatn.h>\n#if defined __LDBL_COMPAT || __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 1\n# include <bits/stdlib-ldbl.h>\n#endif\n\n__END_DECLS\n\n#endif /* stdlib.h  */\n"}, "sourceLanguage": "c"}, {"location": {"uri": "./src/arg_parse.c", "uriBaseId": "PWD"}, "contents": {"text": "#define PACKAGE \"isos-inject\"\n#define PACKAGE_VERSION \"1.0.0\"\n\n#include \"../inc/arg_parse.h\"\n#include <argp.h>\n#include <bfd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nstatic struct argp_option options[] = {\n    {\"file\", 'f', \"FILE\", 0, \"ELF file that will be analyzed\"},\n    {\"binary\", 'b', \"BINARY_FILE\", 0,\n     \"Binary file that we will inject code into\"},\n    {\"section\", 's', \"SECTION\", 0, \"Injected section's name\"},\n    {\"address\", 'a', \"ADDRESS\", 0, \"Base address of the injected code\"},\n    {\"entry\", 'e', 0, 0, \"Whether the entry point should be changed\"},\n    {\"help\", 'h', 0, 0, \"Display this help message and exit.\"},\n    {0}};\n\nstatic char args_doc[] = \"ARG1 ARG2\";\nstatic char doc[] = \"Argument 1 is the ELF file that will be analyzed. \"\n                    \"Argument 2 is the binary \";\n\nstatic error_t parse_opt(int key, char *arg, struct argp_state *state) {\n  cliArgs *args = state->input;\n\n  switch (key) {\n  case 'f':\n    strncpy(args->file, arg, ARG_BUFFER_SIZE);\n    break;\n  case 'b':\n    strncpy(args->binary, arg, ARG_BUFFER_SIZE);\n    break;\n  case 's':\n    strncpy(args->section, arg, ARG_BUFFER_SIZE);\n    break;\n  case 'a':\n    strtoul(args->address, NULL, 16);\n    break;\n  case 'e':\n    args->entry = true;\n    break;\n  case 'h':\n    argp_state_help(state, stdout, ARGP_HELP_STD_HELP);\n    break;\n  case ARGP_KEY_ARG:\n    if (state->arg_num > 5) {\n      fprintf(stderr, \"Too many arguments !\");\n      argp_usage(state);\n    }\n\n    switch (state->arg_num) {\n    case 0:\n      strncpy(args->file, arg, ARG_BUFFER_SIZE);\n      break;\n    case 1:\n      strncpy(args->binary, arg, ARG_BUFFER_SIZE);\n      break;\n    case 2:\n      strncpy(args->section, arg, ARG_BUFFER_SIZE);\n      break;\n    case 3:\n      strtoul(args->address, NULL, 16);\n      break;\n    case 4:\n      args->entry = true;\n      break;\n    }\n\n    break;\n\n  default:\n    return ARGP_ERR_UNKNOWN;\n  }\n  return 0;\n}\n\nstatic struct argp argp = {options, parse_opt, args_doc, doc};\n\ncliArgs get_args(int argc, char **argv) {\n  cliArgs args;\n  argp_parse(&argp, argc, argv, 0, 0, &args);\n  return args;\n}\n"}, "sourceLanguage": "c"}], "results": [{"ruleId": "-Wint-conversion", "level": "warning", "message": {"text": "passing argument 1 of 'strtoul' makes pointer from integer without a cast"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./src/arg_parse.c", "uriBaseId": "PWD"}, "region": {"startLine": 41, "startColumn": 13, "endColumn": 26}, "contextRegion": {"startLine": 41, "snippet": {"text": "    strtoul(args->address, NULL, 16);\n"}}}, "logicalLocations": [{"name": "parse_opt", "fullyQualifiedName": "parse_opt", "decoratedName": "parse_opt", "kind": "function"}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/stdlib.h"}, "region": {"startLine": 181, "startColumn": 35, "endColumn": 64}, "contextRegion": {"startLine": 181, "snippet": {"text": "extern unsigned long int strtoul (const char *__restrict __nptr,\n"}}}, "message": {"text": "expected 'const char * restrict' but argument is of type 'uint64_t' {aka 'long unsigned int'}"}}]}, {"ruleId": "-Wint-conversion", "level": "warning", "message": {"text": "passing argument 1 of 'strtoul' makes pointer from integer without a cast"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "./src/arg_parse.c", "uriBaseId": "PWD"}, "region": {"startLine": 66, "startColumn": 15, "endColumn": 28}, "contextRegion": {"startLine": 66, "snippet": {"text": "      strtoul(args->address, NULL, 16);\n"}}}, "logicalLocations": [{"name": "parse_opt", "fullyQualifiedName": "parse_opt", "decoratedName": "parse_opt", "kind": "function"}]}], "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/stdlib.h"}, "region": {"startLine": 181, "startColumn": 35, "endColumn": 64}, "contextRegion": {"startLine": 181, "snippet": {"text": "extern unsigned long int strtoul (const char *__restrict __nptr,\n"}}}, "message": {"text": "expected 'const char * restrict' but argument is of type 'uint64_t' {aka 'long unsigned int'}"}}]}]}]}
